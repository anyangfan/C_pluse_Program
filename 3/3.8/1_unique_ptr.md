# 1.unique_ptr

## 1.1作用

`std::unique_ptr` 是 C++ 中的一个智能指针类，用于管理动态分配的对象，并确保在适当的时候释放内存。它的作用可以总结为以下几点：

1. **独占所有权**：`unique_ptr` 确保在任何时候只有一个指针可以拥有动态分配的对象。这意味着，当你将一个对象分配给 `unique_ptr` 时，其他任何指针都不能指向该对象，从而避免了内存泄漏和悬挂指针等问题。

2. **自动内存管理**：`unique_ptr` 使用 RAII（资源获取即初始化）机制，即在构造函数中分配内存，在析构函数中释放内存。这意味着当 `unique_ptr` 超出作用域时，其指向的对象将自动被销毁，从而避免了手动管理内存的麻烦。

3. **避免显式 delete**：与使用原始指针相比，使用 `unique_ptr` 可以避免显式调用 `delete` 来释放内存。这有助于降低程序中出现内存泄漏和内存错误的可能性。

4. **移动语义支持**：`unique_ptr` 支持移动语义，因此可以通过移动赋值或移动构造将所有权从一个 `unique_ptr` 转移给另一个。这使得在代码中传递所有权变得更加高效。

5. **定制删除器**：`unique_ptr` 允许你提供一个自定义的删除器函数，用于在对象被销毁时执行特定的清理操作。这在需要特殊资源管理时非常有用。

总的来说，`std::unique_ptr` 提供了一种安全、高效和方便的方式来管理动态分配的对象，有助于减少内存泄漏和指针错误，并提高代码的可维护性和安全性。

## 1.2典型用法

当你想要在C++中管理动态分配的内存并确保在不再需要时自动释放资源时，`std::unique_ptr` 是一个很好的选择。它是C++11引入的一种智能指针，提供了独有所有权的语义，这意味着同一时间只能有一个 `unique_ptr` 拥有某个资源。

以下是 `std::unique_ptr` 的一些典型用法：

1. **动态内存管理**：当你需要在堆上动态分配内存时，`std::unique_ptr` 可以确保在不再需要时释放该内存，避免内存泄漏。

    ```cpp
    std::unique_ptr<int> ptr(new int); // 动态分配一个int型内存块
    *ptr = 42; // 对动态分配的内存进行操作
    // 在作用域结束时，unique_ptr会自动释放内存
    ```

2. **容器元素管理**：可以将 `std::unique_ptr` 作为容器的元素，使容器拥有该元素的所有权。

    ```cpp
    std::vector<std::unique_ptr<int>> vec;
    vec.push_back(std::make_unique<int>(42)); // 在vector中存储一个int型的unique_ptr
    ```

3. **避免资源泄漏**：通过使用 `std::unique_ptr`，可以确保资源在适当的时候被释放，即使在函数发生异常或提前返回时也能保证资源的释放。

    ```cpp
    void foo() {
        std::unique_ptr<int> ptr(new int);
        // 在这里发生异常或提前返回，ptr仍然会被正确释放
    }
    ```

4. **动态分配对象**：`std::unique_ptr` 可以用于动态分配对象，而不仅仅是原始数据类型。

    ```cpp
    class MyClass {
        // class definition
    };

    std::unique_ptr<MyClass> obj(new MyClass()); // 动态分配一个MyClass对象
    ```

5. **移动语义**：`std::unique_ptr` 支持移动语义，因此可以通过移动而不是复制来传递所有权，从而提高性能。

```cpp
std::unique_ptr<int> ptr1(new int(42));
std::unique_ptr<int> ptr2 = std::move(ptr1); // ptr1不再拥有资源，所有权转移到ptr2
```

总的来说，`std::unique_ptr` 是一种轻量级、高效的资源管理工具，能够很好地帮助你管理动态分配的内存和其他资源，避免内存泄漏并提高代码的安全性和可维护性。
