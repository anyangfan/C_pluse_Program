# mutex（互斥量）与condition_variable（条件变量）

1. **mutex（互斥量）**：
   - Mutex是一种同步原语，用于实现多线程程序中的互斥访问。它是一种锁，能够确保在同一时间只有一个线程能够访问共享资源，从而避免竞争条件（race condition）。
   - Mutex的用法通常包括`lock()`、`unlock()`等函数。当线程想要访问共享资源时，它会尝试获取mutex的锁，如果锁已经被其他线程持有，则该线程会被阻塞，直到获取到锁为止。一旦访问结束，线程会释放mutex，以便其他线程可以获取它。

2. **condition_variable（条件变量）**：
   - Condition variable是一种线程同步原语，用于在线程之间进行条件通知。它允许一个线程在满足特定条件之前等待，而其他线程可以在条件发生变化时通知等待的线程。
   - Condition variable通常与mutex结合使用。等待线程在获取锁之后调用`wait()`来等待条件的发生，如果条件不满足，线程将被阻塞并释放锁，直到其他线程通过`notify_one()`或`notify_all()`通知等待的线程。通常情况下，等待线程在被唤醒后会重新获取锁，然后检查条件是否满足。

3. **代码解释**：
   - 上述代码定义了一个全局的互斥量（mutex）`mx`和一个全局的条件变量（condition_variable）`scv`，以及一个全局的标志位`ready`。
   - `PrintID`函数是线程的入口函数，它首先获取互斥量的锁，然后在一个while循环中检查全局标志位`ready`是否为true。如果`ready`为false，说明条件不满足，线程会调用`wait()`函数阻塞自己，并释放锁，等待其他线程通过`notify_all()`函数来唤醒它。一旦条件满足，即`ready`为true，线程会输出自己的ID，并结束执行。
   - `RunFunc`函数是主线程调用的函数，它首先获取互斥量的锁，然后将全局标志位`ready`设置为true，表示条件已经满足。接着，它调用`notify_all()`函数来唤醒所有等待的线程。
   - 在`main`函数中，创建了5个线程，并分别调用`PrintID`函数。然后输出一条消息表示线程已经准备好。接着调用`RunFunc`函数来通知所有等待的线程条件已经满足。最后，使用`join()`函数等待所有线程执行完成。

4. **std::unique_lock**(上述代码中为什么没有解锁mutex的操作？)：
    - 在上述代码中，确实存在一个没有显式解锁mutex的操作。这是因为在`PrintID`函数中，`std::unique_lock<std::mutex>`被定义为`lock(mx)`，它会在构造时自动锁定`mx`，而在`PrintID`函数结束时，`std::unique_lock`对象会被销毁，从而自动释放锁，即使没有显式调用`unlock()`。
    - 这是`std::unique_lock`的一个很方便的特性，它允许我们在作用域结束时自动释放锁，避免了忘记解锁mutex而导致的死锁等问题。因此，尽管在代码中没有显式调用`unlock()`函数，但在`PrintID`函数执行完毕后，`std::unique_lock`对象的析构函数会自动释放mutex的锁。
