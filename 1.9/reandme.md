# C++友元与动态内存

## deque

deque（双端队列）容器是C++标准模板库（STL）中的一种序列容器，具有以下主要特点：

1. 双端访问:deque允许在两端高效地插入和删除元素，即支持push_front()（在前端插入）、pop_front()（从前端移除）、push_back()（在后端插入）和pop_back()（从后端移除）操作。这种特性使得deque既可以用作栈（仅在一端插入/删除），也可以用作队列（在一端插入、另一端删除），或者同时在两端进行操作。

2. 随机访问:虽然deque不像vector那样提供连续内存区域上的最佳随机访问性能，但它仍然支持通过索引来直接访问和修改容器内的任意元素。可以使用下标运算符[]或at()方法进行访问。需要注意的是，虽然deque支持随机访问，但由于其内部实现机制（通常基于分段的动态数组），与vector相比，访问速度可能会稍逊一筹。

3. 动态大小调整:deque能够根据需要动态地增加或减少其容量，无需用户手动管理内存。当插入新元素导致容量不足时，它会自动在内部进行扩容；当大量元素被移除导致容器内部有过多未使用的空间时，可能进行适当的缩容。这一特性使得在进行频繁插入和删除操作时，用户无须担心内存管理问题。

4. 迭代器稳定性:在deque容器中，除了插入或删除操作导致元素位置改变的迭代器外，其他已存在的迭代器不会因容器容量调整而失效。这意味着，只要不直接涉及插入或删除操作的位置，迭代器可以安全地跨越容器容量调整的操作。

5. 内部实现:deque的内部实现通常采用一块连续内存（称为“缓冲区”或“页”）的数组，并维护指向这些缓冲区的指针数组。每个缓冲区存储一定数量的元素。这样的设计使得在两端添加或删除元素时，只需更新相关缓冲区的指针，而非移动大量元素，从而保证了操作的高效性。

综上所述，deque容器是一种兼顾了双端插入/删除操作和一定程度随机访问能力的灵活数据结构，适用于需要在序列两端进行高效操作且偶尔需要直接访问特定位置元素的场景。尽管其随机访问性能略逊于vector，但在某些特定操作（如频繁在两端插入/删除）上，其表现优于vector和list。

## 友元类

1. 友元除了函数以外，还可以是类，即一个类可以作另一个类的友元。当一个类作为另一个类的友元时，这就意味着这个类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。
2. 定义友元类的语句格式如下：friend class 类名（即友元类的类名）;

```cpp

void disp(CTestFClassA &obj)
{
  cout <<"结果为:"<< obj.x + obj.y + k;
} // 求类CTestFClassA的某个数据成员到这边来操作

```

该函数名为disp，接受一个CTestFClassA类型的引用obj作为参数。函数通过输出语句将obj的成员变量x和y相加，并加上全局变量k的值，然后将结果输出到标准输出流。该函数的作用是显示CTestFClassA类的某个数据成员的计算结果。

## new

1. `CNewDelete *pobj = new(buffer) CNewDelete();`

    这段代码的功能是在指定的内存缓冲区buffer中创建一个CNewDelete对象，并通过new操作符返回该对象的指针pobj。

    详细解释如下：

    1.new操作符用于动态分配内存，并调用构造函数初始化对象。在这里，new操作符的参数是buffer，即指定的内存缓冲区。
    2.CNewDelete是一个类，CNewDelete()是该类的构造函数。通过new操作符调用该构造函数，完成对象的初始化。
    3.*pobj表示指针pobj，它将指向新创建的CNewDelete对象。
    4.整段代码的执行结果是，pobj将指向位于buffer中的CNewDelete对象。

2. 上述代码，在内存缓冲区buffer中创建一个CNewDelete对象，是否会溢出

    在上述代码中，new (buffer) CNewDelete();确实是在内存缓冲区buffer中创建一个CNewDelete对象。至于是否会发生溢出，取决于以下几个因素：

    1.缓冲区大小：buffer必须足够大，能够容纳一个完整的CNewDelete对象，包括其所有成员变量和可能的对齐填充。如果buffer大小小于CNewDelete对象的实际大小，就会发生内存溢出。

    2.缓冲区的有效性：buffer必须是指向有效、可写内存区域的指针。如果buffer指向无效地址或未分配的内存，或者该内存区域不可写，即使大小足够也可能导致程序崩溃或其他未定义行为。

    3.构造函数行为：CNewDelete的构造函数在创建对象时不应超出对象本身的内存范围。如果构造函数内部有不当操作（如过度写入成员变量、动态分配内存失败等）导致额外内存需求超出buffer容量，也可能间接导致溢出。

    综上所述，若要确保上述代码在内存缓冲区buffer中创建CNewDelete对象时不发生溢出，需要确保：
    buffer大小大于等于CNewDelete对象的大小。
    buffer指向有效、可写的内存区域。
    CNewDelete的构造函数正常执行，不涉及超出对象本身内存范围的操作。
    在实际编程中，应确保这些条件得到满足，以避免内存溢出问题。如果不确定buffer大小或有效性，或者无法控制CNewDelete构造函数的行为，建议使用标准库提供的动态内存管理功能（如std::unique_ptr、std::make_unique等），而非直接在预分配的缓冲区中创建对象。
